name: Build and Release Native Binaries

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0
  workflow_dispatch:  # Allow manual triggering
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        default: 'v0.1.0'

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Build matrix for different platforms
  build-native:
    name: Build ${{ matrix.platform }}-${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS builds
          # - platform: darwin
          #   arch: amd64
          #   runner: macos-latest
          #   rust_target: x86_64-apple-darwin
            
          - platform: darwin
            arch: arm64
            runner: macos-latest
            rust_target: aarch64-apple-darwin
          
          # # Linux builds
          # - platform: linux
          #   arch: amd64
          #   runner: ubuntu-latest
          #   rust_target: x86_64-unknown-linux-gnu

          # - platform: linux
          #   arch: arm64
          #   runner: ubuntu-latest
          #   rust_target: aarch64-unknown-linux-gnu

          # # Windows builds
          # - platform: windows
          #   arch: amd64
          #   runner: windows-latest
          #   rust_target: x86_64-pc-windows-msvc

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}
          components: rustfmt, clippy

      - name: Install cbindgen
        run: cargo install cbindgen --force

      # Install system dependencies
      - name: Install system dependencies (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler

      - name: Install system dependencies (macOS)
        if: matrix.platform == 'darwin'
        run: |
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            echo "üç∫ Installing protobuf on macOS..."
            
            # Update Homebrew to ensure we get the latest formulas
            brew update || true
            
            # Install protobuf with verbose output
            brew install protobuf
            
            # Verify installation
            echo "üîç Verifying protoc installation..."
            which protoc || echo "‚ùå protoc not found in PATH"
            protoc --version || echo "‚ùå protoc version check failed"
            
            # Add common protoc paths to PATH as fallback
            echo "üîß Ensuring protoc is in PATH..."
            export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
            echo "/opt/homebrew/bin" >> $GITHUB_PATH
            echo "/usr/local/bin" >> $GITHUB_PATH
            
            # Set PROTOC environment variable explicitly
            PROTOC_PATH=$(which protoc)
            echo "PROTOC=$PROTOC_PATH" >> $GITHUB_ENV
            export PROTOC="$PROTOC_PATH"
            
            # Final verification
            echo "‚úÖ Final protoc check:"
            echo "protoc path: $PROTOC_PATH"
            echo "PROTOC env var: $PROTOC"
            which protoc
            protoc --version
            
          else
            echo "‚ö†Ô∏è Cannot build macOS target on $RUNNER_OS runner"
            echo "This requires an actual macOS runner (normal when using 'act')"
            echo "Skipping macOS build..."
            exit 78  # Neutral exit code
          fi

      - name: Install system dependencies (Windows)
        if: matrix.platform == 'windows' && runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "üèóÔ∏è Installing protobuf compiler for Windows..."
          $installed = $false
          
          # Method 1: Try winget with correct package ID
          Write-Host "üì¶ Method 1: Trying winget..."
          # Try different potential package IDs
          $winget_packages = @("protocolbuffers.protobuf", "Google.ProtocolBuffers", "protobuf")
          foreach ($pkg in $winget_packages) {
            Write-Host "Trying package ID: $pkg"
            $result = winget install --id $pkg --accept-package-agreements --accept-source-agreements --disable-interactivity 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ Protobuf installed via winget (package: $pkg)"
              $installed = $true
              break
            } else {
              Write-Host "‚ùå Failed with package ID: $pkg"
              Write-Host $result
            }
          }
          
          # Method 2: Try chocolatey if winget failed
          if (-not $installed) {
            Write-Host "üì¶ Method 2: Trying chocolatey..."
            $result = choco install protoc --yes 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ Protobuf installed via chocolatey"
              $installed = $true
            } else {
              Write-Host "‚ùå Chocolatey failed:"
              Write-Host $result
            }
          }
          
          # Method 3: Manual download if both failed
          if (-not $installed) {
            Write-Host "üì¶ Method 3: Manual download..."
            try {
              $protoc_url = "https://github.com/protocolbuffers/protobuf/releases/download/v25.1/protoc-25.1-win64.zip"
              $protoc_zip = "$env:TEMP\protoc.zip"
              $protoc_dir = "$env:TEMP\protoc"
              
              Write-Host "Downloading from: $protoc_url"
              Invoke-WebRequest -Uri $protoc_url -OutFile $protoc_zip -UseBasicParsing
              
              Write-Host "Extracting to: $protoc_dir"
              if (Test-Path $protoc_dir) { Remove-Item $protoc_dir -Recurse -Force }
              Expand-Archive -Path $protoc_zip -DestinationPath $protoc_dir -Force
              
              # Add to PATH for current session and future steps
              $protoc_bin = "$protoc_dir\bin"
              $env:PATH = "$protoc_bin;$env:PATH"
              Add-Content $env:GITHUB_PATH "$protoc_bin"
              
              # Set PROTOC environment variable
              $protoc_exe = "$protoc_bin\protoc.exe"
              if (Test-Path $protoc_exe) {
                $env:PROTOC = $protoc_exe
                Add-Content $env:GITHUB_ENV "PROTOC=$protoc_exe"
                Write-Host "‚úÖ Protobuf installed manually"
                Write-Host "protoc path: $protoc_exe"
                $installed = $true
              } else {
                Write-Host "‚ùå Manual installation failed - protoc.exe not found"
              }
            }
            catch {
              Write-Host "‚ùå Manual download failed: $_"
            }
          }
          
          # Final verification
          Write-Host "üîç Verifying protoc installation..."
          $protoc_path = Get-Command protoc -ErrorAction SilentlyContinue
          if ($protoc_path) {
            Write-Host "‚úÖ protoc found at: $($protoc_path.Source)"
            & protoc --version
            
            # Set PROTOC environment variable if not already set
            if (-not $env:PROTOC) {
              $env:PROTOC = $protoc_path.Source
              Add-Content $env:GITHUB_ENV "PROTOC=$($protoc_path.Source)"
            }
          } else {
            Write-Host "‚ùå protoc not found in PATH after installation attempts"
            Write-Host "Current PATH: $env:PATH"
            exit 1
          }

      - name: Skip Windows build on non-Windows runner
        if: matrix.platform == 'windows' && runner.os != 'Windows'
        run: |
          echo "‚ö†Ô∏è Cannot build Windows target on $RUNNER_OS runner"
          echo "This requires an actual Windows runner (normal when using 'act')"
          echo "Skipping Windows build..."
          exit 78  # Neutral exit code

      # Linux cross-compilation setup
      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.platform == 'linux' && matrix.arch == 'arm64'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      # Cache Rust dependencies
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "rust -> target"
          key: ${{ matrix.platform }}-${{ matrix.arch }}

      # Create directories (Unix)
      - name: Create directories (Unix)
        if: matrix.platform != 'windows'
        run: |
          echo "üìÅ Creating directories for ${{ matrix.platform }}_${{ matrix.arch }}..."
          TARGET_DIR="lib/${{ matrix.platform }}_${{ matrix.arch }}"
          
          # Create lib directory structure
          mkdir -p "$TARGET_DIR"
          mkdir -p include
          
          # Verify directories were created
          echo "‚úÖ Created directories:"
          echo "  - $TARGET_DIR: $(ls -ld "$TARGET_DIR" 2>/dev/null && echo "exists" || echo "failed")"
          echo "  - include: $(ls -ld include 2>/dev/null && echo "exists" || echo "failed")"
          
          # Show overall structure
          echo "üîç Current directory structure:"
          ls -la . || echo "Root directory listing failed"
          ls -la lib/ || echo "lib directory not found or empty"

      # Create directories (Windows)
      - name: Create directories (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          Write-Host "üìÅ Creating directories for ${{ matrix.platform }}_${{ matrix.arch }}..."
          $targetDir = "lib/${{ matrix.platform }}_${{ matrix.arch }}"
          
          # Create directories with Force flag
          New-Item -ItemType Directory -Path $targetDir -Force | Out-Null
          New-Item -ItemType Directory -Path "include" -Force | Out-Null
          
          # Verify directories were created
          Write-Host "‚úÖ Created directories:"
          if (Test-Path $targetDir) { 
            Write-Host "  - $targetDir : exists" 
          } else { 
            Write-Host "  - $targetDir : failed" 
          }
          
          if (Test-Path "include") { 
            Write-Host "  - include : exists" 
          } else { 
            Write-Host "  - include : failed" 
          }
          
          # Show overall structure
          Write-Host "üîç Current directory structure:"
          Get-ChildItem -Name | Write-Host
          Write-Host "lib directory contents:"
          Get-ChildItem lib -Name -ErrorAction SilentlyContinue | Write-Host

      - name: Verify protoc environment (Unix)
        if: matrix.platform != 'windows'
        run: |
          echo "üîç Verifying protoc environment before build..."
          echo "Current PATH: $PATH"
          echo "PROTOC environment variable: ${PROTOC:-not set}"
          echo "Searching for protoc in PATH:"
          which protoc || echo "protoc not found in PATH"
          echo "Manual check for protoc in common locations:"
          ls -la /opt/homebrew/bin/protoc 2>/dev/null && echo "Found: /opt/homebrew/bin/protoc" || echo "Not found: /opt/homebrew/bin/protoc"
          ls -la /usr/local/bin/protoc 2>/dev/null && echo "Found: /usr/local/bin/protoc" || echo "Not found: /usr/local/bin/protoc"
          ls -la /usr/bin/protoc 2>/dev/null && echo "Found: /usr/bin/protoc" || echo "Not found: /usr/bin/protoc"

      - name: Verify protoc environment (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          Write-Host "üîç Verifying protoc environment before build..."
          Write-Host "Current PATH: $env:PATH"
          Write-Host "PROTOC environment variable: $env:PROTOC"
          Write-Host "Searching for protoc in PATH:"
          $protoc_cmd = Get-Command protoc -ErrorAction SilentlyContinue
          if ($protoc_cmd) {
            Write-Host "‚úÖ protoc found at: $($protoc_cmd.Source)"
            & protoc --version
          } else {
            Write-Host "‚ùå protoc not found in PATH"
          }

      - name: Build native library (Unix)
        if: matrix.platform != 'windows'
        run: |
          # Check for cross-compilation issues
          if [[ "${{ matrix.platform }}" == "darwin" && "$RUNNER_OS" != "macOS" ]]; then
            echo "‚ùå Cannot cross-compile macOS targets on $RUNNER_OS"
            echo "This requires an actual macOS runner"
            exit 78  # Neutral exit to skip
          fi
          
          echo "üî® Building for ${{ matrix.platform }}-${{ matrix.arch }} on $RUNNER_OS..."
          
          # Debug environment for protoc issues
          echo "üîç Environment debug:"
          echo "PATH: $PATH"
          echo "PROTOC: ${PROTOC:-not set}"
          
          # Ensure protoc is available (fallback installation)
          if ! which protoc >/dev/null 2>&1; then
            echo "‚ö†Ô∏è protoc not found, attempting fallback installation..."
            if [[ "$RUNNER_OS" == "macOS" ]]; then
              echo "Installing protobuf via brew (fallback)..."
              brew install protobuf || echo "‚ùå Brew installation failed"
              # Add paths after installation
              export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
            elif [[ "$RUNNER_OS" == "Linux" ]]; then
              echo "Installing protobuf-compiler via apt (fallback)..."
              sudo apt-get update && sudo apt-get install -y protobuf-compiler || echo "‚ùå Apt installation failed"
            fi
          fi
          
          # Final protoc verification and environment setup
          PROTOC_PATH=$(which protoc)
          if [[ -z "$PROTOC_PATH" ]]; then
            echo "‚ùå protoc still not found after installation attempts"
            echo "Checking common locations:"
            ls -la /opt/homebrew/bin/protoc 2>/dev/null || echo "Not found: /opt/homebrew/bin/protoc"
            ls -la /usr/local/bin/protoc 2>/dev/null || echo "Not found: /usr/local/bin/protoc"
            ls -la /usr/bin/protoc 2>/dev/null || echo "Not found: /usr/bin/protoc"
            exit 1
          fi
          
          export PROTOC="$PROTOC_PATH"
          echo "‚úÖ protoc is ready for build"
          echo "protoc path: $PROTOC_PATH"
          echo "PROTOC env var: $PROTOC"
          protoc --version
          
          cd rust
          cargo build --release --target ${{ matrix.rust_target }}
        env:
          RUST_TARGET: ${{ matrix.rust_target }}
          PROTOC: ${{ env.PROTOC }}

      - name: Build native library (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          Write-Host "üî® Building for ${{ matrix.platform }}-${{ matrix.arch }} on Windows..."
          
          # Debug environment for protoc issues
          Write-Host "üîç Environment debug:"
          Write-Host "PATH: $env:PATH"
          Write-Host "PROTOC: $env:PROTOC"
          
          # Ensure protoc is available
          $protoc_cmd = Get-Command protoc -ErrorAction SilentlyContinue
          if (-not $protoc_cmd) {
            Write-Host "‚ùå protoc not found in PATH"
            Write-Host "Current PATH: $env:PATH"
            exit 1
          }
          
          # Set PROTOC environment variable if not set
          if (-not $env:PROTOC) {
            $env:PROTOC = $protoc_cmd.Source
          }
          
          Write-Host "‚úÖ protoc is ready for build"
          Write-Host "protoc path: $($protoc_cmd.Source)"
          Write-Host "PROTOC env var: $env:PROTOC"
          & protoc --version
          
          Set-Location rust
          cargo build --release --target ${{ matrix.rust_target }}
        env:
          RUST_TARGET: ${{ matrix.rust_target }}
          PROTOC: ${{ env.PROTOC }}

      - name: Generate C header
        if: matrix.platform == 'darwin' && matrix.arch == 'amd64'  # Generate header only once
        run: |
          if [[ "$RUNNER_OS" != "macOS" ]]; then
            echo "‚ö†Ô∏è Skipping header generation on $RUNNER_OS (requires macOS)"
            exit 78
          fi
          cd rust
          cbindgen --config cbindgen.toml --crate lancedb-go --output ../include/lancedb.h

      # Copy libraries - macOS/Linux
      - name: Copy libraries (Unix)
        if: matrix.platform != 'windows'
        run: |
          # Skip if cross-compilation was skipped
          if [[ "${{ matrix.platform }}" == "darwin" && "$RUNNER_OS" != "macOS" ]]; then
            echo "‚ö†Ô∏è Skipping library copy (build was skipped)"
            exit 78
          fi
          
          echo "üìÇ Preparing to copy libraries for ${{ matrix.platform }}_${{ matrix.arch }}..."
          
          # Get absolute paths to avoid relative path issues
          WORKSPACE_ROOT="$(pwd)"
          TARGET_DIR="lib/${{ matrix.platform }}_${{ matrix.arch }}"
          ABSOLUTE_TARGET_DIR="$WORKSPACE_ROOT/$TARGET_DIR"
          RUST_BUILD_DIR="$WORKSPACE_ROOT/rust/target/${{ matrix.rust_target }}/release"
          
          echo "üîç Path information:"
          echo "  - Workspace root: $WORKSPACE_ROOT"
          echo "  - Target directory: $TARGET_DIR"
          echo "  - Absolute target: $ABSOLUTE_TARGET_DIR"
          echo "  - Rust build dir: $RUST_BUILD_DIR"
          
          # Ensure target directory exists using absolute path
          echo "üìÅ Creating target directory: $ABSOLUTE_TARGET_DIR"
          mkdir -p "$ABSOLUTE_TARGET_DIR"
          
          # Verify directory was created
          if [ -d "$ABSOLUTE_TARGET_DIR" ]; then
            echo "‚úÖ Target directory exists: $ABSOLUTE_TARGET_DIR"
            ls -la "$ABSOLUTE_TARGET_DIR" || echo "Directory listing failed"
          else
            echo "‚ùå Failed to create target directory: $ABSOLUTE_TARGET_DIR"
            exit 1
          fi
          
          # Debug: Show current directory structure
          echo "üîç Current directory structure:"
          ls -la . || echo "Root directory listing failed"
          ls -la lib/ || echo "lib directory listing failed"
          
          # Check rust build directory
          echo "üìÅ Checking build directory: $RUST_BUILD_DIR"
          if [ ! -d "$RUST_BUILD_DIR" ]; then
            echo "‚ùå Build directory not found: $RUST_BUILD_DIR"
            exit 1
          fi
          
          ls -la "$RUST_BUILD_DIR" || { echo "‚ùå Cannot list build directory"; exit 1; }
          
          cd "$RUST_BUILD_DIR"
          echo "üìã Contents of build directory:"
          ls -la *lancedb* || echo "No lancedb files found"
          
          # Copy static library (always present) using absolute path
          if [ -f liblancedb_go.a ]; then
            echo "üì¶ Copying static library: liblancedb_go.a"
            echo "  From: $(pwd)/liblancedb_go.a"
            echo "  To: $ABSOLUTE_TARGET_DIR/"
            cp liblancedb_go.a "$ABSOLUTE_TARGET_DIR/"
            echo "‚úÖ Static library copied"
          else
            echo "‚ùå Static library liblancedb_go.a not found"
            echo "Available files:"
            ls -la . || echo "Cannot list current directory"
            exit 1
          fi
          
          # Copy dynamic library if it exists (platform-specific) using absolute path
          if [ -f liblancedb_go.dylib ]; then
            echo "üì¶ Copying macOS dynamic library: liblancedb_go.dylib"
            echo "  From: $(pwd)/liblancedb_go.dylib"
            echo "  To: $ABSOLUTE_TARGET_DIR/"
            cp liblancedb_go.dylib "$ABSOLUTE_TARGET_DIR/"
            echo "‚úÖ macOS dynamic library copied"
          fi
          
          if [ -f liblancedb_go.so ]; then
            echo "üì¶ Copying Linux dynamic library: liblancedb_go.so"
            echo "  From: $(pwd)/liblancedb_go.so"
            echo "  To: $ABSOLUTE_TARGET_DIR/"
            cp liblancedb_go.so "$ABSOLUTE_TARGET_DIR/"
            echo "‚úÖ Linux dynamic library copied"
          fi
          
          # Verify files were copied successfully using absolute path
          echo "üîç Verifying copied files in: $ABSOLUTE_TARGET_DIR"
          ls -la "$ABSOLUTE_TARGET_DIR/" || echo "Failed to list target directory"

      # Copy libraries - Windows
      - name: Copy libraries (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          # Skip if cross-compilation was skipped
          if ($env:RUNNER_OS -ne "Windows") {
            Write-Host "‚ö†Ô∏è Skipping library copy (build was skipped)"
            exit 78
          }
          
          Write-Host "üìÇ Preparing to copy libraries for ${{ matrix.platform }}_${{ matrix.arch }}..."
          
          # Get absolute paths to avoid relative path issues
          $workspaceRoot = Get-Location
          $targetDir = "lib/${{ matrix.platform }}_${{ matrix.arch }}"
          $absoluteTargetDir = Join-Path $workspaceRoot $targetDir
          $rustBuildDir = Join-Path $workspaceRoot "rust/target/${{ matrix.rust_target }}/release"
          
          Write-Host "üîç Path information:"
          Write-Host "  - Workspace root: $workspaceRoot"
          Write-Host "  - Target directory: $targetDir"
          Write-Host "  - Absolute target: $absoluteTargetDir"
          Write-Host "  - Rust build dir: $rustBuildDir"
          
          # Ensure target directory exists using absolute path
          Write-Host "üìÅ Creating target directory: $absoluteTargetDir"
          New-Item -ItemType Directory -Path $absoluteTargetDir -Force | Out-Null
          
          # Verify directory was created
          if (Test-Path $absoluteTargetDir) {
            Write-Host "‚úÖ Target directory exists: $absoluteTargetDir"
            Get-ChildItem $absoluteTargetDir -ErrorAction SilentlyContinue | Write-Host
          } else {
            Write-Host "‚ùå Failed to create target directory: $absoluteTargetDir"
            exit 1
          }
          
          # Debug: Show current directory structure
          Write-Host "üîç Current directory structure:"
          Get-ChildItem -Name | Write-Host
          Write-Host "lib directory contents:"
          Get-ChildItem lib -Name -ErrorAction SilentlyContinue | Write-Host
          
          # Check rust build directory
          Write-Host "üìÅ Checking build directory: $rustBuildDir"
          if (-not (Test-Path $rustBuildDir)) {
            Write-Host "‚ùå Build directory not found: $rustBuildDir"
            exit 1
          }
          
          Set-Location $rustBuildDir
          Write-Host "üìã Contents of build directory:"
          Get-ChildItem -Filter "*lancedb*" | Format-Table Name, Length -AutoSize
          
          # Copy static library (.a is preferred for CGO compatibility) using absolute path
          $staticCopied = $false
          if (Test-Path "liblancedb_go.a") {
            Write-Host "üì¶ Copying static library: liblancedb_go.a"
            Write-Host "  From: $(Get-Location)\liblancedb_go.a"
            Write-Host "  To: $absoluteTargetDir\"
            Copy-Item liblancedb_go.a $absoluteTargetDir
            Write-Host "‚úÖ Static library copied (liblancedb_go.a)"
            $staticCopied = $true
          } elseif (Test-Path "lancedb_go.lib") {
            Write-Host "üì¶ Copying static library: lancedb_go.lib"
            Write-Host "  From: $(Get-Location)\lancedb_go.lib"
            Write-Host "  To: $absoluteTargetDir\"
            Copy-Item lancedb_go.lib $absoluteTargetDir
            Write-Host "‚úÖ Static library copied (lancedb_go.lib)"
            $staticCopied = $true
          } elseif (Test-Path "liblancedb_go.lib") {
            Write-Host "üì¶ Copying static library: liblancedb_go.lib"
            Write-Host "  From: $(Get-Location)\liblancedb_go.lib"
            Write-Host "  To: $absoluteTargetDir\"
            Copy-Item liblancedb_go.lib $absoluteTargetDir
            Write-Host "‚úÖ Static library copied (liblancedb_go.lib)"
            $staticCopied = $true
          }
          
          if (-not $staticCopied) {
            Write-Host "‚ùå No static library found (.a, .lib)"
            Write-Host "Available files:"
            Get-ChildItem -Filter "*lancedb*" | Format-Table Name, Length -AutoSize
            exit 1
          }
          
          # Copy dynamic library (.dll) if it exists using absolute path
          if (Test-Path "lancedb_go.dll") {
            Write-Host "üì¶ Copying dynamic library: lancedb_go.dll"
            Write-Host "  From: $(Get-Location)\lancedb_go.dll"
            Write-Host "  To: $absoluteTargetDir\"
            Copy-Item lancedb_go.dll $absoluteTargetDir
            Write-Host "‚úÖ Dynamic library copied (lancedb_go.dll)"
          } elseif (Test-Path "liblancedb_go.dll") {
            Write-Host "üì¶ Copying dynamic library: liblancedb_go.dll"
            Write-Host "  From: $(Get-Location)\liblancedb_go.dll"
            Write-Host "  To: $absoluteTargetDir\"
            Copy-Item liblancedb_go.dll $absoluteTargetDir
            Write-Host "‚úÖ Dynamic library copied (liblancedb_go.dll)"
          } else {
            Write-Host "‚ö†Ô∏è No dynamic library found (.dll)"
            Write-Host "This is expected for static builds"
          }
          
          # Verify files were copied successfully using absolute path
          Write-Host "üîç Verifying copied files in: $absoluteTargetDir"
          Get-ChildItem $absoluteTargetDir | Format-Table Name, Length -AutoSize

      # Upload artifacts for each platform
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lancedb-go-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            lib/${{ matrix.platform }}_${{ matrix.arch }}/
            include/
          retention-days: 7

  # Create release with all binaries
  create-release:
    name: Create Release
    needs: build-native
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Download all build artifacts
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true

      # Verify all expected files exist
      - name: Verify binaries
        run: |
          echo "üîç Verifying binary files..."
          find lib/ -name "*.a" -o -name "*.so" -o -name "*.dylib" -o -name "*.lib" -o -name "*.dll" | sort
          
          echo "üìù Verifying header files..."
          ls -la include/
          
          # Check that we have binaries for all expected platforms
          expected_platforms="darwin_amd64 darwin_arm64 linux_amd64 linux_arm64 windows_amd64"
          for platform in $expected_platforms; do
            if [ ! -d "lib/$platform" ]; then
              echo "‚ùå Missing binaries for platform: $platform"
            fi
            echo "‚úÖ Found binaries for platform: $platform"
          done

      # Create archive with all binaries
      - name: Create release archive
        run: |
          echo "üì¶ Creating release archive..."
          
          # Create a comprehensive README for the release
          cat > RELEASE_NOTES.md << 'EOF'
          # LanceDB Go SDK - Native Binaries Release
          
          This release contains pre-built native libraries for the LanceDB Go SDK.
          
          ## Installation
          
          ```bash
          go get github.com/lancedb/lancedb-go
          ```
          
          No additional build steps required! The native libraries are included.
          
          ## Supported Platforms
          
          - **macOS**: Intel (amd64) and Apple Silicon (arm64)
          - **Linux**: Intel/AMD (amd64) and ARM (arm64)  
          - **Windows**: Intel/AMD (amd64)
          
          ## Files Included
          
          - `include/lancedb.h` - C header file
          - `lib/darwin_amd64/` - macOS Intel binaries
          - `lib/darwin_arm64/` - macOS Apple Silicon binaries  
          - `lib/linux_amd64/` - Linux AMD64 binaries
          - `lib/linux_arm64/` - Linux ARM64 binaries
          - `lib/windows_amd64/` - Windows AMD64 binaries
          
          ## Usage
          
          See the examples in the `examples/` directory for usage patterns.
          EOF
          
          # Create archive
          tar -czf lancedb-go-native-binaries.tar.gz lib/ include/ RELEASE_NOTES.md
          
          echo "‚úÖ Release archive created: lancedb-go-native-binaries.tar.gz"
          tar -tzf lancedb-go-native-binaries.tar.gz | head -20

      # Get version from tag or input
      - name: Get version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.version }}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üìã Release version: $VERSION"

      # Note: We don't commit binary files to the repository
      # Instead, we distribute them via GitHub Releases
      - name: Prepare binary distribution
        run: |
          echo "üì¶ Preparing binary distribution for GitHub Release..."
          echo "Binary files will be attached to the GitHub Release, not committed to the repository."
          
          # Verify all binary files are present
          echo "üîç Verifying binary files for release..."
          find lib/ -name "*.a" -o -name "*.so" -o -name "*.dylib" -o -name "*.lib" -o -name "*.dll" | sort
          
          # Show size information
          echo "üìä Binary file sizes:"
          du -h lib/*/

      # Create GitHub release with all binary files
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: LanceDB Go SDK ${{ steps.get_version.outputs.version }}
          body_path: RELEASE_NOTES.md
          files: |
            lancedb-go-native-binaries.tar.gz
            lib/darwin_amd64/liblancedb_go.a
            lib/darwin_amd64/liblancedb_go.dylib
            lib/darwin_arm64/liblancedb_go.a
            lib/darwin_arm64/liblancedb_go.dylib
            lib/linux_amd64/liblancedb_go.a
            lib/linux_amd64/liblancedb_go.so
            lib/linux_arm64/liblancedb_go.a
            lib/linux_arm64/liblancedb_go.so
            lib/windows_amd64/lancedb_go.lib
            lib/windows_amd64/lancedb_go.dll
            include/lancedb.h
          draft: false
          prerelease: ${{ contains(steps.get_version.outputs.version, 'alpha') || contains(steps.get_version.outputs.version, 'beta') || contains(steps.get_version.outputs.version, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Test the release by trying to use it
      - name: Test release installation
        run: |
          echo "üß™ Testing release installation..."
          
          # Create a temporary Go module to test installation
          cd /tmp
          mkdir lancedb-test
          cd lancedb-test
          
          go mod init lancedb-test
          go get github.com/lancedb/lancedb-go@${{ steps.get_version.outputs.version }}
          
          echo "‚úÖ Release installation test passed!"